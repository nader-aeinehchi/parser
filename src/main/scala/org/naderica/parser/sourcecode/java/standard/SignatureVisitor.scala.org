package org.naderica.parser.sourcecode.java.standard

import java.util.ArrayList
import java.util.List
import java.util.Stack

import org.antlr.v4.runtime.CommonTokenStream
import org.antlr.v4.runtime.misc.Interval
import org.naderica.parser.sourcecode.ast.java.standard.Java20Parser.*
import org.naderica.parser.sourcecode.ast.java.standard.Java20ParserBaseVisitor

class SignatureVisitor(val tokens: CommonTokenStream)
    extends Java20ParserBaseVisitor[Unit] {

  private val classStack = new Stack[ClassInfo]()
  private val topLevelClasses = new ArrayList[ClassInfo]()

  def visitNormalClassDeclaration(ctx: NormalClassDeclarationContext): Unit = {

    val classSignature = tokens
      .getText(
        new Interval(
          ctx.start.getTokenIndex,
          ctx.classBody().start.getTokenIndex - 1
        )
      )
      .trim

    println(s"classSignature: $classSignature")

    val currentClass = new ClassInfo()
    currentClass.data.signature = classSignature

// Add the new class to the appropriate list (top-level or inner).
    if (classStack.isEmpty) {
      topLevelClasses.add(currentClass)
    } else {
      classStack.peek().data.innerClasses.add(currentClass)
    }

// Push the current class onto the stack to track nesting.
    classStack.push(currentClass)

// Continue visiting children to find methods and inner classes.
    super.visitNormalClassDeclaration(ctx)

// Pop the class from the stack when we're done visiting its
  }

  /** Overrides the visit for a method declaration. Adds the method's signature
    * to the current class on the stack.
    */
  override def visitMethodDeclaration(ctx: MethodDeclarationContext): Unit = {
    // Get the text from the start of the method to the start of its body.
    val methodSignature = tokens
      .getText(
        new Interval(
          ctx.start.getTokenIndex,
          ctx.methodBody().start.getTokenIndex - 1
        )
      )
      .trim

    println(s"methodSignature: $methodSignature")

    // Add the signature to the most recently added class on the stack.
    if (!classStack.isEmpty) {
      classStack.peek().data.memberSignatures.add(methodSignature)
    }

    // Do not visit children as we only need the signature.
    ()
  }

  /** Overrides the visit for a constructor declaration. Adds the constructor's
    * signature to the current class on the stack.
    */
  override def visitConstructorDeclaration(
      ctx: ConstructorDeclarationContext
  ): Unit = {
    // Get the text from the start of the constructor to the start of its body.
    val constructorSignature = tokens
      .getText(
        new Interval(
          ctx.start.getTokenIndex,
          ctx.constructorBody().start.getTokenIndex - 1
        )
      )
      .trim

    println(s"constructorSignature: $constructorSignature")

    // Add the signature to the most recently added class on the stack.
    if (!classStack.isEmpty) {
      classStack.peek().data.memberSignatures.add(constructorSignature)
    }

    // Do not visit children as we only need the signature.
    ()
  }

  def getResult: List[ClassInfo] = topLevelClasses

}
